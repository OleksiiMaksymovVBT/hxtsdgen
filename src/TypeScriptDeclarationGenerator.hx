#if macro
import haxe.io.Path;
import haxe.macro.Compiler;
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
using haxe.macro.Tools;
using StringTools;

class TypeScriptDeclarationGenerator {
    static function use() {
        Context.onGenerate(function(types) {
            var exposedClasses = [];
            for (type in types) {
                switch (type.follow()) {
                    case TInst(_.get() => cl, _):
                        if (cl.meta.has(":expose") || Lambda.exists(cl.statics.get(), function(f) return f.meta.has(":expose")))
                            exposedClasses.push(cl);
                    default:
                }
            }
            if (exposedClasses.length > 0)
                Context.onAfterGenerate(function() {
                    var declarations = ["// Generated by Haxe TypeScript Declaration Generator :)"];
                    for (cl in exposedClasses) {
                        if (cl.meta.has(":expose")) {
                            declarations.push(generateClassDeclaration(cl));
                        }
                    }
                    var outJS = Compiler.getOutput();
                    var outDTS = Path.withoutExtension(outJS) + ".d.ts";
                    sys.io.File.saveContent(outDTS, declarations.join("\n\n"));
                });
        });
    }

    static function generateClassDeclaration(cl:ClassType):String {
        var parts = [];
        parts.push('declare class ${cl.name} {');

        inline function addDoc(doc:String) {
            if (doc != null) {
                parts.push("\t/**");
                var lines = doc.split("\n");
                for (line in lines) {
                    line = line.trim();
                    if (line.length > 0)
                        parts.push('\t * $line');
                }
                parts.push("\t */");
            }
        }

        if (cl.constructor != null) {
            var ctor = cl.constructor.get();
            if (ctor.isPublic)
                addDoc(ctor.doc);
                switch (ctor.type) {
                    case TFun(args, _):
                        var args = args.map(convertArg);
                        parts.push('\tconstructor(${args.join(", ")});');
                    default: throw "wtf";
                }
        }

        inline function addField(field:ClassField, isStatic:Bool) {
            if (field.isPublic) {
                addDoc(field.doc);

                var prefix = if (isStatic) "static " else "";

                switch [field.kind, field.type] {
                    case [FMethod(_), TFun(args, ret)]:
                        var args = args.map(convertArg);
                        parts.push('\t$prefix${field.name}(${args.join(", ")}): ${convertTypeRef(ret)};');

                    case [FVar(_,write), _]:
                        switch (write) {
                            case AccNo|AccNever:
                                prefix += "readonly ";
                            default:
                        }
                        parts.push('\t$prefix${field.name}: ${convertTypeRef(field.type)};');

                    default:
                }
            }
        }

        for (field in cl.fields.get()) {
            addField(field, false);
        }

        for (field in cl.statics.get()) {
            addField(field, true);
        }

        parts.push('}');
        return parts.join("\n");
    }

    static function convertArg(arg:{name:String, opt:Bool, t:Type}):String {
        var argString = arg.name;
        if (arg.opt) argString += "?";
        argString += ": " + convertTypeRef(arg.t);
        return argString;
    }

    static function convertTypeRef(t:Type):String {
        return switch (t.followWithAbstracts().toString()) {
            case "String": "string";
            case "Int" | "Float": "number";
            case "Bool": "boolean";
            case "Void": "void";
            case other: other;
        }
    }
}
#end
